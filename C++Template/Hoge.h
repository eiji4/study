#pragma once


///////////////////////////////////////////////////////////////////////////////
// 
//	Template クラスで、かつ別の型の Template 関数を持っている場合。
//  Template 関数を定義するときに、template キーワードが2重に重なっている事に注目。
// 
///////////////////////////////////////////////////////////////////////////////

template<class T>
class Hoge
{
public:
	T value = 4.4;

	// template メンバ関数宣言
	template<class U>
	U convert(float val);
};

// template メンバ関数を別の場所で定義。 template キーワードが2重に重なっている事に注目。
// この関数を cpp 側で定義して明示的にインスタンス化させるにはどうしたらいいんだ・・・・？
template<class T>
template<class U>
U Hoge<T>::convert(float val) {
	return val;
}



///////////////////////////////////////////////////////////////////////////////
// 
//	Template クラスのメンバ関数を cpp で定義する場合。
//  cpp ファイル内で使う予定の型のインスタンスを作成する。
//  逆に言うと、cpp で定義されていない型は使えなくなるので、
//  ライブラリを提供するときに予期しない型でインスタンス化されるのを防ぐことができる。
// 
///////////////////////////////////////////////////////////////////////////////

template<class T>
class Foo
{
public:
	T value = 44.44;
	T GetValue();
};




///////////////////////////////////////////////////////////////////////////////
// 
//	Template クラスに存在しない関数が使われている場合。
//  cpp ファイル内で必要な関数だけをインスタンス化。
// 
///////////////////////////////////////////////////////////////////////////////

template<class T = float>
class Bar
{
public:
	T value = 22.22;
	T GetValue();
	int CallNotExistedFunc() {
		// 存在しない関数を呼び出しても、実際にコードで使われないとテンプレートクラス内の関数はインスタンス化されない。
		return T.my_non_existance();
	}
};




///////////////////////////////////////////////////////////////////////////////
// 
//	Template 引数は型以外にも整数を取れる。整数のみで、float や double は使えない。
// 
///////////////////////////////////////////////////////////////////////////////

template<class T, int N = 4>
class MyArray
{
public:
	T float_array[N];
	int NumArray() { return sizeof(float_array)/sizeof(T); }
};